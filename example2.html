<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Webcam Mixer</title>
   <style>
       * { margin: 0; padding: 0; box-sizing: border-box; }
       body { font-family: Arial, sans-serif; background: #222; color: white; }

       #controls {
           padding: 10px;
           background: #333;
           border-bottom: 2px solid #555;
           display: flex;
           gap: 10px;
           flex-wrap: wrap;
           align-items: center;
       }

       button {
           padding: 8px 16px;
           background: #4CAF50;
           color: white;
           border: none;
           cursor: pointer;
           border-radius: 4px;
       }

       button:hover { background: #45a049; }

       .control-group {
           display: flex;
           gap: 5px;
           align-items: center;
           background: #444;
           padding: 5px 10px;
           border-radius: 4px;
       }

       .control-group label { font-size: 12px; }
       .control-group input { width: 60px; }

       #canvas-container {
           position: relative;
           width: 1920px;
           height: 1080px;
           margin: 20px auto;
           background: #000;
           overflow: hidden;
       }

       .video-wrapper {
           position: absolute;
           border: 2px solid #4CAF50;
           cursor: move;
           overflow: hidden;
       }

       .video-wrapper.selected { border-color: #ff9800; box-shadow: 0 0 10px #ff9800; }

       .video-wrapper video,
       .video-wrapper canvas {
           position: absolute;
           pointer-events: none;
           transform-origin: top left;
       }

       .resize-handle {
           position: absolute;
           bottom: 0;
           right: 0;
           width: 20px;
           height: 20px;
           background: #ff9800;
           cursor: nwse-resize;
           z-index: 10;
       }

       .delete-btn {
           position: absolute;
           top: 5px;
           right: 5px;
           padding: 2px 8px;
           background: #f44336;
           font-size: 12px;
           z-index: 10;
       }

       /* Fullscreen styles */
       :fullscreen #controls {
           display: none;
       }

       :-webkit-full-screen #controls {
           display: none;
       }

       :-moz-full-screen #controls {
           display: none;
       }

       :fullscreen #canvas-container {
           margin: 0;
           width: 100vw;
           height: 100vh;
       }

       :-webkit-full-screen #canvas-container {
           margin: 0;
           width: 100vw;
           height: 100vh;
       }

       :-moz-full-screen #canvas-container {
           margin: 0;
           width: 100vw;
           height: 100vh;
       }

       :fullscreen .video-wrapper {
           border: none !important;
           box-shadow: none !important;
       }

       :-webkit-full-screen .video-wrapper {
           border: none !important;
           box-shadow: none !important;
       }

       :-moz-full-screen .video-wrapper {
           border: none !important;
           box-shadow: none !important;
       }

       :fullscreen .resize-handle,
       :fullscreen .delete-btn {
           display: none;
       }

       :-webkit-full-screen .resize-handle,
       :-webkit-full-screen .delete-btn {
           display: none;
       }

       :-moz-full-screen .resize-handle,
       :-moz-full-screen .delete-btn {
           display: none;
       }
   </style>
</head>
<body>
   <div id="controls">
       <button onclick="startCam1()">Start Webcam 1</button>
       <button onclick="startCam2()">Start Webcam 2</button>
       <button onclick="addSpectrogram()">Spectrogram</button>
       <button onclick="zeroSpectrogram()">Zero Spectrogram</button>
       <button onclick="resetSpectrogram()">Reset Spectrogram</button>
       <button onclick="duplicateSelected()">Duplicate Selected</button>
       <button onclick="document.documentElement.requestFullscreen()">Fullscreen</button>

       <div class="control-group" id="video-controls" style="display: none;">
           <label>Pan X:</label>
           <input type="number" id="panX" value="0" onchange="updateVideoTransform()">
           <label>Pan Y:</label>
           <input type="number" id="panY" value="0" onchange="updateVideoTransform()">
           <label>Zoom:</label>
           <input type="number" id="zoom" value="100" step="10" min="10" max="500" onchange="updateVideoTransform()">%
       </div>
   </div>

   <div id="canvas-container"></div>

   <script>
       const container = document.getElementById('canvas-container');
       const videoControls = document.getElementById('video-controls');
       let streams = {};
       let selected = null;
       let videoCount = 0;

       async function startCam1() {
           const stream = await navigator.mediaDevices.getUserMedia({
               video: { width: { ideal: 9999 } },
               audio: true
           });
           streams.cam1 = stream;
           addVideo(stream, 'cam1');
       }

       async function startCam2() {
           const devices = await navigator.mediaDevices.enumerateDevices();
           const videoDevices = devices.filter(d => d.kind === 'videoinput');
           const constraint = videoDevices.length > 1
               ? { deviceId: videoDevices[1].deviceId, width: { ideal: 9999 } }
               : { width: { ideal: 9999 } };
           const stream = await navigator.mediaDevices.getUserMedia({ video: constraint });
           streams.cam2 = stream;
           addVideo(stream, 'cam2');
       }

       function addVideo(stream, sourceId) {
           const wrapper = document.createElement('div');
           wrapper.className = 'video-wrapper';
           wrapper.style.left = '50px';
           wrapper.style.top = (50 + videoCount * 50) + 'px';
           wrapper.style.width = '640px';
           wrapper.style.height = '480px';
           wrapper.dataset.source = sourceId;
           wrapper.dataset.panX = '0';
           wrapper.dataset.panY = '0';
           wrapper.dataset.zoom = '100';

           const video = document.createElement('video');
           video.srcObject = stream;
           video.autoplay = true;
           video.muted = true;
           video.playsInline = true;

           const resize = document.createElement('div');
           resize.className = 'resize-handle';

           const deleteBtn = document.createElement('button');
           deleteBtn.className = 'delete-btn';
           deleteBtn.textContent = '×';
           deleteBtn.onclick = (e) => {
               e.stopPropagation();
               if (selected === wrapper) {
                   selected = null;
                   videoControls.style.display = 'none';
               }
               // Detach but don't stop the shared stream
               const videoEl = wrapper.querySelector('video');
               videoEl.srcObject = null;
               wrapper.remove();
           };

           wrapper.appendChild(video);
           wrapper.appendChild(resize);
           wrapper.appendChild(deleteBtn);
           container.appendChild(wrapper);

           // Once we know the native resolution, size everything to match
           video.addEventListener('loadedmetadata', () => {
               const nw = video.videoWidth;
               const nh = video.videoHeight;
               wrapper.style.width = nw + 'px';
               wrapper.style.height = nh + 'px';
               video.style.width = nw + 'px';
               video.style.height = nh + 'px';
           });

           makeDraggable(wrapper);
           makeResizable(wrapper, resize);
           enableZoomAndPan(wrapper);

           wrapper.onclick = () => selectVideo(wrapper);

           // Double click to reset to native view
           wrapper.addEventListener('dblclick', (e) => {
               if (e.target.tagName !== 'BUTTON') {
                   const v = wrapper.querySelector('video');
                   wrapper.dataset.zoom = '100';
                   wrapper.dataset.panX = '0';
                   wrapper.dataset.panY = '0';
                   v.style.width = wrapper.offsetWidth + 'px';
                   v.style.height = wrapper.offsetHeight + 'px';
                   applyTransform(wrapper);
               }
           });

           videoCount++;
       }

       function updateVideoSize(wrapper, video) {
           video.style.width = wrapper.offsetWidth + 'px';
           video.style.height = wrapper.offsetHeight + 'px';
       }

       function selectVideo(wrapper) {
           if (selected) selected.classList.remove('selected');
           selected = wrapper;
           wrapper.classList.add('selected');

           // Update controls to show current values
           document.getElementById('panX').value = wrapper.dataset.panX;
           document.getElementById('panY').value = wrapper.dataset.panY;
           document.getElementById('zoom').value = wrapper.dataset.zoom;
           videoControls.style.display = 'flex';
       }

       function updateVideoTransform() {
           if (!selected) return;

           const panX = parseFloat(document.getElementById('panX').value);
           const panY = parseFloat(document.getElementById('panY').value);
           const zoom = parseFloat(document.getElementById('zoom').value) / 100;

           selected.dataset.panX = panX;
           selected.dataset.panY = panY;
           selected.dataset.zoom = zoom * 100;

           const el = selected.querySelector('video') || selected.querySelector('canvas');
           el.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
       }

       function applyTransform(wrapper) {
           const panX = parseFloat(wrapper.dataset.panX);
           const panY = parseFloat(wrapper.dataset.panY);
           const zoom = parseFloat(wrapper.dataset.zoom) / 100;

           const el = wrapper.querySelector('video') || wrapper.querySelector('canvas');
           el.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;

           // Update controls if this is the selected video
           if (wrapper === selected) {
               document.getElementById('panX').value = wrapper.dataset.panX;
               document.getElementById('panY').value = wrapper.dataset.panY;
               document.getElementById('zoom').value = wrapper.dataset.zoom;
           }
       }

       function enableZoomAndPan(wrapper) {
           // Scroll wheel zoom - zoom towards mouse cursor
           wrapper.addEventListener('wheel', (e) => {
               e.preventDefault();

               const rect = wrapper.getBoundingClientRect();
               const mouseX = e.clientX - rect.left;
               const mouseY = e.clientY - rect.top;

               const oldZoom = parseFloat(wrapper.dataset.zoom) / 100;
               const delta = e.deltaY > 0 ? -10 : 10;
               const newZoomPercent = Math.max(10, Math.min(500, parseFloat(wrapper.dataset.zoom) + delta));
               const newZoom = newZoomPercent / 100;

               // Calculate the point in the video that the mouse is over
               const oldPanX = parseFloat(wrapper.dataset.panX);
               const oldPanY = parseFloat(wrapper.dataset.panY);

               // The point in the original video coordinates
               const videoPointX = (mouseX - oldPanX) / oldZoom;
               const videoPointY = (mouseY - oldPanY) / oldZoom;

               // Calculate new pan to keep the same point under the mouse
               const newPanX = mouseX - videoPointX * newZoom;
               const newPanY = mouseY - videoPointY * newZoom;

               wrapper.dataset.zoom = newZoomPercent;
               wrapper.dataset.panX = newPanX;
               wrapper.dataset.panY = newPanY;

               applyTransform(wrapper);
           });

           // Right-click pan
           wrapper.addEventListener('contextmenu', (e) => {
               e.preventDefault();
           });

           wrapper.addEventListener('mousedown', (e) => {
               if (e.button === 2) { // Right click
                   e.preventDefault();
                   e.stopPropagation();

                   const startX = e.clientX;
                   const startY = e.clientY;
                   const startPanX = parseFloat(wrapper.dataset.panX);
                   const startPanY = parseFloat(wrapper.dataset.panY);

                   const onMouseMove = (e) => {
                       const deltaX = e.clientX - startX;
                       const deltaY = e.clientY - startY;
                       wrapper.dataset.panX = startPanX + deltaX;
                       wrapper.dataset.panY = startPanY + deltaY;
                       applyTransform(wrapper);
                   };

                   const onMouseUp = () => {
                       document.removeEventListener('mousemove', onMouseMove);
                       document.removeEventListener('mouseup', onMouseUp);
                   };

                   document.addEventListener('mousemove', onMouseMove);
                   document.addEventListener('mouseup', onMouseUp);
               }
           });
       }

       function duplicateSelected() {
           if (!selected) return;
           const sourceId = selected.dataset.source;
           if (sourceId === 'spectrogram') {
               addSpectrogram();
           } else if (streams[sourceId]) {
               addVideo(streams[sourceId], sourceId);
           }
       }

       // ---- Spectrogram ----
       let spectrograms = []; // track active spectrogram instances

       function zeroSpectrogram() {
           spectrograms.forEach(s => {
               s.analyser.getByteFrequencyData(s.dataArray);
               s.baseline = new Uint8Array(s.dataArray);
           });
       }

       function resetSpectrogram() {
           spectrograms.forEach(s => {
               s.baseline = null;
           });
       }

       async function addSpectrogram() {
           // Use cam1's audio if available, otherwise request mic directly
           let audioStream;
           if (streams.cam1) {
               const audioTracks = streams.cam1.getAudioTracks();
               if (audioTracks.length > 0) {
                   audioStream = streams.cam1;
               }
           }
           if (!audioStream) {
               audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
           }

           const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
           const source = audioCtx.createMediaStreamSource(audioStream);
           const analyser = audioCtx.createAnalyser();
           analyser.fftSize = 2048;
           analyser.smoothingTimeConstant = 0.8;
           source.connect(analyser);

           const freqBinCount = analyser.frequencyBinCount;
           const specWidth = 800;
           const specHeight = 400;

           const wrapper = document.createElement('div');
           wrapper.className = 'video-wrapper';
           wrapper.style.left = '50px';
           wrapper.style.top = (50 + videoCount * 50) + 'px';
           wrapper.style.width = specWidth + 'px';
           wrapper.style.height = specHeight + 'px';
           wrapper.dataset.source = 'spectrogram';
           wrapper.dataset.panX = '0';
           wrapper.dataset.panY = '0';
           wrapper.dataset.zoom = '100';

           const canvas = document.createElement('canvas');
           canvas.width = specWidth;
           canvas.height = specHeight;
           canvas.style.width = specWidth + 'px';
           canvas.style.height = specHeight + 'px';
           const ctx = canvas.getContext('2d');

           const resize = document.createElement('div');
           resize.className = 'resize-handle';

           const deleteBtn = document.createElement('button');
           deleteBtn.className = 'delete-btn';
           deleteBtn.textContent = '\u00d7';

           let animId = null;

           deleteBtn.onclick = (e) => {
               e.stopPropagation();
               if (selected === wrapper) {
                   selected = null;
                   videoControls.style.display = 'none';
               }
               if (animId) cancelAnimationFrame(animId);
               spectrograms = spectrograms.filter(s => s !== specState);
               source.disconnect();
               wrapper.remove();
           };

           wrapper.appendChild(canvas);
           wrapper.appendChild(resize);
           wrapper.appendChild(deleteBtn);
           container.appendChild(wrapper);

           makeDraggable(wrapper);
           makeResizable(wrapper, resize);
           enableZoomAndPan(wrapper);

           wrapper.onclick = () => selectVideo(wrapper);

           wrapper.addEventListener('dblclick', (e) => {
               if (e.target.tagName !== 'BUTTON') {
                   wrapper.dataset.zoom = '100';
                   wrapper.dataset.panX = '0';
                   wrapper.dataset.panY = '0';
                   applyTransform(wrapper);
               }
           });

           // Scrolling spectrogram — advance 1 column every ~33ms (30 columns/sec)
           const dataArray = new Uint8Array(freqBinCount);
           const specState = { analyser, dataArray, baseline: null };
           spectrograms.push(specState);

           const msPerColumn = 33;
           let lastColumnTime = performance.now();

           function draw(now) {
               animId = requestAnimationFrame(draw);

               // Only advance columns at a fixed rate
               const elapsed = now - lastColumnTime;
               if (elapsed < msPerColumn) return;

               // Catch up missed columns (cap at 3 to avoid freeze-burst)
               const columns = Math.min(Math.floor(elapsed / msPerColumn), 3);
               lastColumnTime += columns * msPerColumn;

               analyser.getByteFrequencyData(dataArray);

               const w = canvas.width;
               const h = canvas.height;

               // Shift existing image left by the number of columns
               const imageData = ctx.getImageData(columns, 0, w - columns, h);
               ctx.putImageData(imageData, 0, 0);

               // Draw new columns on the right edge
               for (let col = 0; col < columns; col++) {
                   const x = w - columns + col;
                   for (let y = 0; y < h; y++) {
                       const freqIndex = Math.floor((1 - y / h) * freqBinCount);
                       let value = dataArray[freqIndex] || 0;

                       if (specState.baseline) {
                           value = Math.max(0, value - specState.baseline[freqIndex]);
                       }

                       const norm = value / 255;

                       let r, g, b;
                       if (norm < 0.25) {
                           r = 0; g = 0; b = Math.floor(norm * 4 * 255);
                       } else if (norm < 0.5) {
                           r = 0; g = Math.floor((norm - 0.25) * 4 * 255); b = 255;
                       } else if (norm < 0.75) {
                           r = Math.floor((norm - 0.5) * 4 * 255); g = 255; b = Math.floor((1 - (norm - 0.5) * 4) * 255);
                       } else {
                           r = 255; g = 255; b = Math.floor((norm - 0.75) * 4 * 255);
                       }

                       ctx.fillStyle = `rgb(${r},${g},${b})`;
                       ctx.fillRect(x, y, 1, 1);
                   }
               }
           }

           animId = requestAnimationFrame(draw);
           videoCount++;
       }

       function makeDraggable(el) {
           let pos = { x: 0, y: 0, startX: 0, startY: 0 };

           el.onmousedown = (e) => {
               if (e.button !== 0) return; // Only left click
               if (e.target.className === 'resize-handle' || e.target.tagName === 'BUTTON') return;
               e.preventDefault();
               pos.startX = e.clientX;
               pos.startY = e.clientY;

               document.onmousemove = (e) => {
                   pos.x = e.clientX - pos.startX;
                   pos.y = e.clientY - pos.startY;
                   pos.startX = e.clientX;
                   pos.startY = e.clientY;
                   el.style.left = (el.offsetLeft + pos.x) + 'px';
                   el.style.top = (el.offsetTop + pos.y) + 'px';
               };

               document.onmouseup = () => {
                   document.onmousemove = null;
                   document.onmouseup = null;
               };
           };
       }

       function makeResizable(el, handle) {
           handle.onmousedown = (e) => {
               e.preventDefault();
               e.stopPropagation();
               const startX = e.clientX;
               const startY = e.clientY;
               const startW = el.offsetWidth;
               const startH = el.offsetHeight;

               document.onmousemove = (e) => {
                   const newW = startW + e.clientX - startX;
                   const newH = startH + e.clientY - startY;
                   el.style.width = newW + 'px';
                   el.style.height = newH + 'px';
                   const inner = el.querySelector('video') || el.querySelector('canvas');
                   if (inner) {
                       inner.style.width = newW + 'px';
                       inner.style.height = newH + 'px';
                       if (inner.tagName === 'CANVAS') {
                           inner.width = newW;
                           inner.height = newH;
                       }
                   }
               };

               document.onmouseup = () => {
                   document.onmousemove = null;
                   document.onmouseup = null;
               };
           };
       }
   </script>
</body>
</html>