<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Mixer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden;
        }

        #controls {
            padding: 12px 16px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 7px 14px;
            background: #0f3460;
            color: #e0e0e0;
            border: 1px solid #1a4a8a;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            transition: background 0.15s, border-color 0.15s;
        }

        button:hover {
            background: #1a4a8a;
            border-color: #2a6ad0;
        }

        .btn-accent {
            background: #1b8a5a;
            border-color: #24b474;
        }

        .btn-accent:hover {
            background: #24b474;
            border-color: #2ed88e;
        }

        .separator {
            width: 1px;
            height: 28px;
            background: #0f3460;
        }

        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
            background: #0f3460;
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #1a4a8a;
        }

        .control-group label {
            font-size: 12px;
            color: #8899aa;
            white-space: nowrap;
        }

        .control-group input,
        .control-group select {
            background: #16213e;
            color: #e0e0e0;
            border: 1px solid #1a4a8a;
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 12px;
            font-family: inherit;
        }

        .control-group input { width: 60px; }
        .control-group select { max-width: 200px; }

        #canvas-container {
            position: relative;
            background: #000;
            overflow: hidden;
            border-radius: 0 0 4px 4px;
            transform-origin: top left;
        }

        .video-wrapper {
            position: absolute;
            border: 2px solid transparent;
            cursor: move;
            overflow: visible;
        }

        .video-wrapper.spectrogram-source {
            border-color: #666;
        }

        .video-wrapper.selected {
            border-color: #ff0000;
            border-style: dashed;
        }

        .video-wrapper video,
        .video-wrapper canvas {
            position: absolute;
            pointer-events: none;
            transform-origin: top left;
        }

        .video-wrapper .inner-clip {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #fff;
            border: 1px solid #f00;
            z-index: 20;
            display: none;
        }

        .video-wrapper.selected .handle { display: block; }

        .handle-nw { top: -5px; left: -5px; cursor: nw-resize; }
        .handle-n  { top: -5px; left: 50%; margin-left: -5px; cursor: n-resize; }
        .handle-ne { top: -5px; right: -5px; cursor: ne-resize; }
        .handle-e  { top: 50%; margin-top: -5px; right: -5px; cursor: e-resize; }
        .handle-se { bottom: -5px; right: -5px; cursor: se-resize; }
        .handle-s  { bottom: -5px; left: 50%; margin-left: -5px; cursor: s-resize; }
        .handle-sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .handle-w  { top: 50%; margin-top: -5px; left: -5px; cursor: w-resize; }

        .handle-rotate {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #fff;
            border: 2px solid #f00;
            border-radius: 50%;
            top: -37px;
            left: 50%;
            margin-left: -7px;
            cursor: grab;
            z-index: 20;
            display: none;
        }

        .video-wrapper.selected .handle-rotate { display: block; }

        .handle-line {
            position: absolute;
            width: 2px;
            height: 30px;
            background: #f00;
            top: -30px;
            left: 50%;
            margin-left: -1px;
            z-index: 19;
            display: none;
            pointer-events: none;
        }

        .video-wrapper.selected .handle-line { display: block; }

        :fullscreen,
        :-webkit-full-screen {
            background: #000;
        }

        :fullscreen #controls,
        :-webkit-full-screen #controls {
            display: none;
        }

        :fullscreen #canvas-container,
        :-webkit-full-screen #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
        }

        :fullscreen .video-wrapper,
        :-webkit-full-screen .video-wrapper {
            border: none !important;
        }

        :fullscreen .handle,
        :fullscreen .handle-rotate,
        :fullscreen .handle-line,
        :-webkit-full-screen .handle,
        :-webkit-full-screen .handle-rotate,
        :-webkit-full-screen .handle-line {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button class="btn-accent" onclick="startCam1()">Webcam 1</button>
        <button class="btn-accent" onclick="startCam2()">Webcam 2</button>
        <div class="separator"></div>
        <button onclick="addSpectrogram()">Spectrogram</button>
        <button onclick="zeroSpectrogram()">Zero</button>
        <button onclick="resetSpectrogram()">Reset</button>
        <div class="separator"></div>
        <button onclick="duplicateSelected()">Duplicate</button>
        <button onclick="document.documentElement.requestFullscreen()">Fullscreen</button>

        <div class="control-group" id="video-controls" style="visibility: hidden;">
            <label>Pan X:</label>
            <input type="number" id="panX" value="0" onchange="updateVideoTransform()">
            <label>Y:</label>
            <input type="number" id="panY" value="0" onchange="updateVideoTransform()">
            <label>Zoom:</label>
            <input type="number" id="zoom" value="100" step="10" min="10" max="500" onchange="updateVideoTransform()">%
            <label>Rot:</label>
            <input type="number" id="rotation" value="0" step="90" onchange="updateVideoTransform()">&deg;
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        const container = document.getElementById('canvas-container');
        const videoControls = document.getElementById('video-controls');
        const controlsEl = document.getElementById('controls');
        const elPanX = document.getElementById('panX');
        const elPanY = document.getElementById('panY');
        const elZoom = document.getElementById('zoom');
        const elRotation = document.getElementById('rotation');
        const streams = {};
        let selected = null;
        let videoCount = 0;
        let spectrograms = [];

        const CANVAS_W = screen.width;
        const CANVAS_H = screen.height;
        container.style.width = CANVAS_W + 'px';
        container.style.height = CANVAS_H + 'px';

        // --- Precomputed color LUT for spectrogram (256 entries, each [r,g,b]) ---
        const colorLUT = new Uint8Array(256 * 3);
        for (let i = 0; i < 256; i++) {
            const norm = i / 255;
            let r, g, b;
            if (norm < 0.25) {
                r = 0; g = 0; b = norm * 4 * 255;
            } else if (norm < 0.5) {
                r = 0; g = (norm - 0.25) * 4 * 255; b = 255;
            } else if (norm < 0.75) {
                r = (norm - 0.5) * 4 * 255; g = 255; b = (1 - (norm - 0.5) * 4) * 255;
            } else {
                r = 255; g = 255; b = (norm - 0.75) * 4 * 255;
            }
            const off = i * 3;
            colorLUT[off] = r;
            colorLUT[off + 1] = g;
            colorLUT[off + 2] = b;
        }

        // --- Container scaling ---

        function updateContainerScale() {
            let scale, offsetX, offsetY;
            if (document.fullscreenElement) {
                scale = Math.max(window.innerWidth / CANVAS_W, window.innerHeight / CANVAS_H);
                offsetX = (window.innerWidth - CANVAS_W * scale) / 2;
                offsetY = (window.innerHeight - CANVAS_H * scale) / 2;
            } else {
                const availH = Math.max(100, window.innerHeight - controlsEl.offsetHeight);
                scale = Math.min(availH / CANVAS_H, window.innerWidth / CANVAS_W);
                offsetX = (window.innerWidth - CANVAS_W * scale) / 2;
                offsetY = 0;
            }
            container.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }

        updateContainerScale();
        document.addEventListener('fullscreenchange', updateContainerScale);
        window.addEventListener('resize', updateContainerScale);

        // --- Keyboard shortcuts ---

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            if ((e.key === 'r' || e.key === 'R') && selected) {
                e.preventDefault();
                rotateSelected();
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && selected) {
                e.preventDefault();
                deleteSelected();
            }
        });

        // --- Handle creation ---

        const handleIds = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];

        function createHandles(wrapper) {
            for (const id of handleIds) {
                const h = document.createElement('div');
                h.className = `handle handle-${id}`;
                h.dataset.handle = id;
                h.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startHandleResize(wrapper, id, e);
                });
                wrapper.appendChild(h);
            }

            const line = document.createElement('div');
            line.className = 'handle-line';
            wrapper.appendChild(line);

            const rotHandle = document.createElement('div');
            rotHandle.className = 'handle-rotate';
            rotHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startHandleRotate(wrapper, e);
            });
            wrapper.appendChild(rotHandle);
        }

        // --- Wrapper position from center ---

        function updateWrapperPosition(wrapper) {
            const cx = parseFloat(wrapper.dataset.cx);
            const cy = parseFloat(wrapper.dataset.cy);
            wrapper.style.left = (cx - wrapper.offsetWidth / 2) + 'px';
            wrapper.style.top = (cy - wrapper.offsetHeight / 2) + 'px';
            wrapper.style.transform = `rotate(${parseFloat(wrapper.dataset.rotation) || 0}deg)`;
        }

        // --- Resize with rotation ---

        function startHandleResize(wrapper, handleId, e) {
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const startW = wrapper.offsetWidth;
            const startH = wrapper.offsetHeight;
            const startCX = parseFloat(wrapper.dataset.cx);
            const startCY = parseFloat(wrapper.dataset.cy);
            const rotation = parseFloat(wrapper.dataset.rotation) || 0;
            const rad = rotation * Math.PI / 180;
            const cosR = Math.cos(rad);
            const sinR = Math.sin(rad);
            const containerScale = container.getBoundingClientRect().width / CANVAS_W;
            const isCorner = handleId.length === 2;

            const onMove = (e) => {
                const rawDX = (e.clientX - startMouseX) / containerScale;
                const rawDY = (e.clientY - startMouseY) / containerScale;
                const localDX = rawDX * cosR + rawDY * sinR;
                const localDY = -rawDX * sinR + rawDY * cosR;

                let newW = startW;
                let newH = startH;
                let shiftX = 0;
                let shiftY = 0;

                if (handleId.includes('e')) {
                    newW = Math.max(30, startW + localDX);
                    shiftX = (newW - startW) / 2;
                }
                if (handleId.includes('w')) {
                    newW = Math.max(30, startW - localDX);
                    shiftX = -(newW - startW) / 2;
                }
                if (handleId.includes('s')) {
                    newH = Math.max(30, startH + localDY);
                    shiftY = (newH - startH) / 2;
                }
                if (handleId.includes('n')) {
                    newH = Math.max(30, startH - localDY);
                    shiftY = -(newH - startH) / 2;
                }

                if (isCorner) {
                    const scale = Math.max(newW / startW, newH / startH);
                    newW = Math.max(30, startW * scale);
                    newH = Math.max(30, startH * scale);
                    shiftX = 0; shiftY = 0;
                    if (handleId.includes('e')) shiftX = (newW - startW) / 2;
                    if (handleId.includes('w')) shiftX = -(newW - startW) / 2;
                    if (handleId.includes('s')) shiftY = (newH - startH) / 2;
                    if (handleId.includes('n')) shiftY = -(newH - startH) / 2;
                }

                wrapper.style.width = newW + 'px';
                wrapper.style.height = newH + 'px';
                wrapper.dataset.cx = startCX + shiftX * cosR - shiftY * sinR;
                wrapper.dataset.cy = startCY + shiftX * sinR + shiftY * cosR;

                const inner = wrapper.querySelector('video') || wrapper.querySelector('canvas');
                if (inner) {
                    inner.style.width = newW + 'px';
                    inner.style.height = newH + 'px';
                    if (inner.tagName === 'CANVAS') {
                        inner.width = Math.round(newW);
                        inner.height = Math.round(newH);
                    }
                }

                updateWrapperPosition(wrapper);
            };

            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }

        // --- Rotation handle ---

        function startHandleRotate(wrapper, e) {
            e.preventDefault();
            const containerRect = container.getBoundingClientRect();
            const containerScale = containerRect.width / CANVAS_W;
            const rectLeft = containerRect.left;
            const rectTop = containerRect.top;

            const onMove = (e) => {
                const cx = parseFloat(wrapper.dataset.cx);
                const cy = parseFloat(wrapper.dataset.cy);
                const mouseCanvasX = (e.clientX - rectLeft) / containerScale;
                const mouseCanvasY = (e.clientY - rectTop) / containerScale;

                let angle = Math.atan2(mouseCanvasX - cx, -(mouseCanvasY - cy)) * 180 / Math.PI;
                angle = ((angle % 360) + 360) % 360;

                if (!e.shiftKey) {
                    for (const c of [0, 90, 180, 270, 360]) {
                        if (Math.abs(angle - c) < 3) {
                            angle = c % 360;
                            break;
                        }
                    }
                }

                wrapper.dataset.rotation = angle;
                updateWrapperPosition(wrapper);

                if (wrapper === selected) {
                    elRotation.value = Math.round(angle);
                }
            };

            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }

        // --- Shared wrapper helpers ---

        function createWrapper(sourceId) {
            const wrapper = document.createElement('div');
            wrapper.className = 'video-wrapper';
            wrapper.dataset.source = sourceId;
            wrapper.dataset.panX = '0';
            wrapper.dataset.panY = '0';
            wrapper.dataset.zoom = '100';
            wrapper.dataset.rotation = '0';

            const innerClip = document.createElement('div');
            innerClip.className = 'inner-clip';
            wrapper.appendChild(innerClip);

            createHandles(wrapper);

            return { wrapper, innerClip };
        }

        function setupWrapper(wrapper) {
            container.appendChild(wrapper);
            makeDraggable(wrapper);
            enableZoomAndPan(wrapper);

            wrapper.addEventListener('mousedown', (e) => {
                if (e.button === 0) selectVideo(wrapper);
            });

            wrapper.addEventListener('dblclick', () => {
                wrapper.dataset.zoom = '100';
                wrapper.dataset.panX = '0';
                wrapper.dataset.panY = '0';
                const inner = wrapper.querySelector('video') || wrapper.querySelector('canvas');
                if (inner) {
                    inner.style.width = wrapper.offsetWidth + 'px';
                    inner.style.height = wrapper.offsetHeight + 'px';
                }
                applyTransform(wrapper);
            });

            videoCount++;
        }

        function removeWrapper(wrapper) {
            if (selected === wrapper) {
                selected = null;
                videoControls.style.visibility = 'hidden';
            }
            if (wrapper._cleanup) wrapper._cleanup();
            wrapper.remove();
        }

        function deleteSelected() {
            if (selected) removeWrapper(selected);
        }

        // --- Webcam ---

        async function startCam1() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 9999 } },
                audio: true
            });
            streams.cam1 = stream;
            addVideo(stream, 'cam1');
        }

        async function startCam2() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(d => d.kind === 'videoinput');
            const constraint = videoDevices.length > 1
                ? { deviceId: videoDevices[1].deviceId, width: { ideal: 9999 } }
                : { width: { ideal: 9999 } };
            const stream = await navigator.mediaDevices.getUserMedia({ video: constraint });
            streams.cam2 = stream;
            addVideo(stream, 'cam2');
        }

        function addVideo(stream, sourceId) {
            const { wrapper, innerClip } = createWrapper(sourceId);
            wrapper.style.width = '640px';
            wrapper.style.height = '480px';

            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            innerClip.appendChild(video);

            video.addEventListener('loadedmetadata', () => {
                const nw = video.videoWidth;
                const nh = video.videoHeight;
                const fitScale = Math.min(CANVAS_W / 3 / nw, 1);
                const w = Math.round(nw * fitScale);
                const h = Math.round(nh * fitScale);
                wrapper.style.width = w + 'px';
                wrapper.style.height = h + 'px';
                video.style.width = w + 'px';
                video.style.height = h + 'px';

                const left = parseFloat(wrapper.style.left) || (50 + videoCount * 50);
                const top = parseFloat(wrapper.style.top) || (50 + videoCount * 50);
                wrapper.dataset.cx = left + w / 2;
                wrapper.dataset.cy = top + h / 2;
                updateWrapperPosition(wrapper);
            });

            const initLeft = 50 + videoCount * 50;
            const initTop = 50 + videoCount * 50;
            wrapper.dataset.cx = initLeft + 320;
            wrapper.dataset.cy = initTop + 240;
            updateWrapperPosition(wrapper);

            wrapper._cleanup = () => { video.srcObject = null; };
            setupWrapper(wrapper);
        }

        // --- Selection & transform ---

        function selectVideo(wrapper) {
            if (selected && selected !== wrapper) selected.classList.remove('selected');
            selected = wrapper;
            wrapper.classList.add('selected');

            elPanX.value = wrapper.dataset.panX;
            elPanY.value = wrapper.dataset.panY;
            elZoom.value = wrapper.dataset.zoom;
            elRotation.value = Math.round(parseFloat(wrapper.dataset.rotation));
            videoControls.style.visibility = 'visible';
        }

        container.addEventListener('mousedown', (e) => {
            if (e.target === container && selected) {
                selected.classList.remove('selected');
                selected = null;
                videoControls.style.visibility = 'hidden';
            }
        });

        function rotateSelected() {
            if (!selected) return;
            selected.dataset.rotation = (parseFloat(selected.dataset.rotation) + 90) % 360;
            updateWrapperPosition(selected);
            elRotation.value = Math.round(parseFloat(selected.dataset.rotation));
        }

        function updateVideoTransform() {
            if (!selected) return;
            selected.dataset.panX = parseFloat(elPanX.value);
            selected.dataset.panY = parseFloat(elPanY.value);
            selected.dataset.zoom = parseFloat(elZoom.value);
            selected.dataset.rotation = parseFloat(elRotation.value);

            applyTransform(selected);
            updateWrapperPosition(selected);
        }

        function applyTransform(wrapper) {
            const panX = parseFloat(wrapper.dataset.panX);
            const panY = parseFloat(wrapper.dataset.panY);
            const zoom = parseFloat(wrapper.dataset.zoom) / 100;

            const el = wrapper.querySelector('video') || wrapper.querySelector('canvas');
            if (el) {
                el.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            }

            if (wrapper === selected) {
                elPanX.value = wrapper.dataset.panX;
                elPanY.value = wrapper.dataset.panY;
                elZoom.value = wrapper.dataset.zoom;
                elRotation.value = Math.round(parseFloat(wrapper.dataset.rotation));
            }
        }

        // --- Zoom & pan ---

        function enableZoomAndPan(wrapper) {
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                const el = wrapper.querySelector('video') || wrapper.querySelector('canvas');
                if (!el) return;

                const rect = wrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const oldZoom = parseFloat(wrapper.dataset.zoom) / 100;
                const delta = e.deltaY > 0 ? -10 : 10;
                const newZoomPercent = Math.max(10, Math.min(500, parseFloat(wrapper.dataset.zoom) + delta));
                const newZoom = newZoomPercent / 100;

                const oldPanX = parseFloat(wrapper.dataset.panX);
                const oldPanY = parseFloat(wrapper.dataset.panY);

                const elPointX = (mouseX - oldPanX) / oldZoom;
                const elPointY = (mouseY - oldPanY) / oldZoom;

                wrapper.dataset.zoom = newZoomPercent;
                wrapper.dataset.panX = mouseX - elPointX * newZoom;
                wrapper.dataset.panY = mouseY - elPointY * newZoom;
                applyTransform(wrapper);
            });

            wrapper.addEventListener('contextmenu', (e) => e.preventDefault());

            wrapper.addEventListener('mousedown', (e) => {
                if (e.button !== 2) return;
                e.preventDefault();
                e.stopPropagation();

                const containerScale = container.getBoundingClientRect().width / CANVAS_W;
                const startX = e.clientX;
                const startY = e.clientY;
                const startPanX = parseFloat(wrapper.dataset.panX);
                const startPanY = parseFloat(wrapper.dataset.panY);

                const onMove = (e) => {
                    wrapper.dataset.panX = startPanX + (e.clientX - startX) / containerScale;
                    wrapper.dataset.panY = startPanY + (e.clientY - startY) / containerScale;
                    applyTransform(wrapper);
                };
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        // --- Duplicate ---

        function duplicateSelected() {
            if (!selected) return;
            const sourceId = selected.dataset.source;
            if (sourceId === 'spectrogram') {
                addSpectrogram();
            } else if (streams[sourceId]) {
                addVideo(streams[sourceId], sourceId);
            }
        }

        // --- Spectrogram ---

        function zeroSpectrogram() {
            spectrograms.forEach(s => {
                s.analyser.getByteFrequencyData(s.dataArray);
                s.baseline = new Uint8Array(s.dataArray);
            });
        }

        function resetSpectrogram() {
            spectrograms.forEach(s => { s.baseline = null; });
        }

        async function addSpectrogram() {
            const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioCtx.createMediaStreamSource(audioStream);
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            source.connect(analyser);

            const freqBinCount = analyser.frequencyBinCount;
            const nyquist = audioCtx.sampleRate / 2;
            const maxFreq = Math.min(20000, nyquist);
            const maxBin = Math.floor((maxFreq / nyquist) * freqBinCount);
            const pad = 6;
            const fontSize = 20;
            const axisW = 56;
            const legendH = 48;
            const specWidth = axisW + 800;
            const specHeight = legendH + 400;

            const { wrapper, innerClip } = createWrapper('spectrogram');
            wrapper.classList.add('spectrogram-source');
            wrapper.style.width = specWidth + 'px';
            wrapper.style.height = specHeight + 'px';

            const canvas = document.createElement('canvas');
            canvas.width = specWidth;
            canvas.height = specHeight;
            canvas.style.width = specWidth + 'px';
            canvas.style.height = specHeight + 'px';
            const ctx = canvas.getContext('2d');
            innerClip.appendChild(canvas);

            const dataArray = new Uint8Array(freqBinCount);
            const specState = { analyser, dataArray, baseline: null, animId: null, source };
            spectrograms.push(specState);
            wrapper._specState = specState;
            wrapper._cleanup = () => {
                if (specState.animId) cancelAnimationFrame(specState.animId);
                spectrograms = spectrograms.filter(s => s !== specState);
                if (specState.source) specState.source.disconnect();
            };

            const initLeft = 50 + videoCount * 50;
            const initTop = 50 + videoCount * 50;
            wrapper.dataset.cx = initLeft + specWidth / 2;
            wrapper.dataset.cy = initTop + specHeight / 2;
            updateWrapperPosition(wrapper);

            setupWrapper(wrapper);

            // --- Pre-render static overlay to offscreen canvas ---
            const overlayCanvas = document.createElement('canvas');
            overlayCanvas.width = specWidth;
            overlayCanvas.height = specHeight;
            const oCtx = overlayCanvas.getContext('2d');

            function renderOverlay(w, h) {
                oCtx.clearRect(0, 0, w, h);
                const dataH = h - legendH;
                const minDb = analyser.minDecibels;
                const maxDb = analyser.maxDecibels;

                // Frequency axis
                oCtx.fillStyle = '#000';
                oCtx.fillRect(0, legendH, axisW, dataH);

                const tickFreqs = [2000, 5000, 10000, 20000].filter(f => f <= maxFreq);
                oCtx.fillStyle = '#999';
                oCtx.font = fontSize + 'px monospace';
                oCtx.textAlign = 'right';
                oCtx.textBaseline = 'middle';
                oCtx.strokeStyle = '#666';
                oCtx.lineWidth = 1;

                for (const freq of tickFreqs) {
                    const y = legendH + Math.round(dataH * (1 - freq / maxFreq));
                    const clampedY = Math.max(legendH + fontSize / 2 + pad, Math.min(h - fontSize / 2 - pad, y));
                    oCtx.beginPath();
                    oCtx.moveTo(axisW - 4, y + 0.5);
                    oCtx.lineTo(axisW, y + 0.5);
                    oCtx.stroke();
                    const label = freq >= 1000 ? (freq / 1000) + 'k' : freq + '';
                    oCtx.fillText(label, axisW - pad, clampedY);
                }

                // Color legend
                oCtx.fillStyle = '#000';
                oCtx.fillRect(0, 0, w, legendH);

                const barLeft = axisW + pad;
                const barRight = w - pad;
                const barW = barRight - barLeft;
                const barY = pad;
                const barH = 10;
                for (let px = 0; px < barW; px++) {
                    const idx = Math.round((px / barW) * 255) * 3;
                    oCtx.fillStyle = `rgb(${colorLUT[idx]},${colorLUT[idx+1]},${colorLUT[idx+2]})`;
                    oCtx.fillRect(barLeft + px, barY, 1, barH);
                }
                oCtx.strokeStyle = '#666';
                oCtx.strokeRect(barLeft + 0.5, barY + 0.5, barW - 1, barH - 1);

                const dbRange = maxDb - minDb;
                const dbStep = 20;
                const firstTick = Math.ceil(minDb / dbStep) * dbStep;
                oCtx.fillStyle = '#999';
                oCtx.font = fontSize + 'px monospace';
                oCtx.textBaseline = 'top';
                const labelY = barY + barH + pad;

                for (let db = firstTick; db <= maxDb; db += dbStep) {
                    const norm = (db - minDb) / dbRange;
                    const x = barLeft + norm * barW;
                    oCtx.strokeStyle = '#666';
                    oCtx.beginPath();
                    oCtx.moveTo(x + 0.5, barY + barH);
                    oCtx.lineTo(x + 0.5, barY + barH + 3);
                    oCtx.stroke();
                    oCtx.textAlign = 'center';
                    oCtx.fillText(db + 'dB', x, labelY);
                }
            }

            // Recompute overlay and freqMap for current canvas size
            let cachedW = 0, cachedH = 0;
            let dataH = 0;
            let freqMap = null;

            function rebuildCache(w, h) {
                cachedW = w;
                cachedH = h;
                dataH = h - legendH;

                // Rebuild frequency map
                freqMap = new Uint16Array(dataH);
                for (let row = 0; row < dataH; row++) {
                    freqMap[row] = Math.floor((1 - row / dataH) * maxBin);
                }

                // Rebuild overlay
                overlayCanvas.width = w;
                overlayCanvas.height = h;
                renderOverlay(w, h);
            }

            rebuildCache(specWidth, specHeight);

            // Scrolling spectrogram â€” 30 columns/sec
            const msPerColumn = 33;
            let lastColumnTime = performance.now();

            function draw(now) {
                specState.animId = requestAnimationFrame(draw);

                const elapsed = now - lastColumnTime;
                if (elapsed < msPerColumn) return;

                const columns = Math.min(Math.floor(elapsed / msPerColumn), 3);
                lastColumnTime += columns * msPerColumn;

                analyser.getByteFrequencyData(dataArray);

                const w = canvas.width;
                const h = canvas.height;

                // Rebuild cached overlay & freqMap if canvas was resized
                if (w !== cachedW || h !== cachedH) {
                    rebuildCache(w, h);
                }

                const dataW = w - axisW;

                // Scroll only the data area
                const imageData = ctx.getImageData(axisW + columns, legendH, dataW - columns, dataH);
                ctx.putImageData(imageData, axisW, legendH);

                // Draw new columns using ImageData buffer
                const colData = ctx.createImageData(columns, dataH);
                const pixels = colData.data;
                const baseline = specState.baseline;

                for (let col = 0; col < columns; col++) {
                    for (let row = 0; row < dataH; row++) {
                        let value = dataArray[freqMap[row]] || 0;
                        if (baseline) {
                            value = Math.max(0, value - baseline[freqMap[row]]);
                        }
                        const lutOff = value * 3;
                        const pxOff = (row * columns + col) * 4;
                        pixels[pxOff] = colorLUT[lutOff];
                        pixels[pxOff + 1] = colorLUT[lutOff + 1];
                        pixels[pxOff + 2] = colorLUT[lutOff + 2];
                        pixels[pxOff + 3] = 255;
                    }
                }
                ctx.putImageData(colData, axisW + dataW - columns, legendH);

                // Blit cached overlay
                ctx.drawImage(overlayCanvas, 0, 0);
            }

            specState.animId = requestAnimationFrame(draw);
        }

        // --- Drag ---

        function makeDraggable(el) {
            el.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (e.target.classList.contains('handle') || e.target.classList.contains('handle-rotate')) return;
                e.preventDefault();

                const containerScale = container.getBoundingClientRect().width / CANVAS_W;
                let lastX = e.clientX;
                let lastY = e.clientY;

                const onMove = (e) => {
                    const dx = (e.clientX - lastX) / containerScale;
                    const dy = (e.clientY - lastY) / containerScale;

                    el.dataset.cx = parseFloat(el.dataset.cx) + dx;
                    el.dataset.cy = parseFloat(el.dataset.cy) + dy;
                    updateWrapperPosition(el);

                    lastX = e.clientX;
                    lastY = e.clientY;
                };

                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
    </script>
</body>
</html>
